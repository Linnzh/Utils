## 生成器模式 - Builder

概念：一种创建型设计模式，分步骤创建复杂对象，该模式允许你使用相同的创建代码生成不同类型和形式的对象。

![生成器设计模式](assets/设计模式/builder-zh.png)



假设有这样一个复杂对象，在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中；甚至还有更糟糕的情况，那就是这些代码散落在客户端代码的多个位置。

生成器模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为*生成器*的独立对象中。又称为“建造者模式（Builder）”。

![应用生成器模式](assets/设计模式/solution1.png)

你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的*主管*类。主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。

### 适用性

- 想避免 “重叠构造函数 （telescopic constructor）” 的出现时
- 当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时
- 想构造[组合](https://refactoringguru.cn/design-patterns/composite)树或其他复杂对象时

### 特点

生成器模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 生成器方法通常支持方法链 （例如 `someBuilder->setValueA(1)->setValueB(2)->create()` ）。

### 参与者

- **生成器** （Builder）
    - 接口声明在所有类型生成器中通用的产品构造步骤。
- **具体生成器** （Concrete Builders）
    - 提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品。
- **产品** （Products）
    - 是最终生成的对象。由不同生成器构造的产品无需属于同一类层次结构或接口。
- **主管** （Director）
    - 类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。
- **客户端** （Client）
    - 必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能使用生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。

### 案例

- SQL 查询生成器：生成器接口定义了生成一般 SQL 查询所需的通用步骤。另一方面，对应不同 SQL 语言的具体生成器会去实现这些步骤，返回能在特定数据库引擎中执行的 SQL 查询语句。
- 分步构建一部汽车：汽车构建器、汽车手册生成器、汽车类型、汽车特征1……汽车特征n、主管控制生成器控制生成不同种的汽车。

### 对现有业务的思考

很适合用来生成不同种类的产品，以及一些初始化工作，例如：创建一家公司，需要部件：生成创始人、生成工厂地址/发货地址、生成默认配送方式、生成空仓库、生成初始账户、设定默认结算规则、设定默认结算货币、设定默认文件存储方式等。

简单测试代码以供理解：

```php
public function testExample(): void
{
    $director = new Director();
    echo "\n";

    $carBuilder = new CarBuilder();
    $director->buildSportsCar($carBuilder);
    echo $carBuilder . "\n\n";

    $manualBuilder = new ManualBuilder();
    $director->buildSUVCar($manualBuilder);
    echo $manualBuilder . "\n\n";

    $this->assertEquals(true, true);
}
```


## 备忘录模式 - Memento

概念：**在不破坏封装性的前提下**，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

别名：Token。有时有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复过来，需要实现**检查点**和**取消**机制，而要实现这些机制，必须事先将状态信息保存在某处，这样才能将对象恢复到它们先前的状态。

但是对象通常封装了其部分或所有状态信息，使得其状态不能被其他对象访问，也就不可能在该对象之外保存其状态。而暴露其内部状态又将违反封装的原则，可能有损应用的可靠性和可扩展性。

一个备忘录是一个对象，它存储另一个对象在某个瞬间的内部状态，而后者称为备忘录的**原发器（Originator）**。当需要设置原发器的检查点时，取消操作机制会向原发器请求一个备忘录。原发器用描述当前状态的信息初始化该备忘录（创建快照）。只有原发器可以向备忘录中存取信息，备忘录对其他对象“不可见”。

![原发器拥有对备忘录的完全权限，负责人则只能访问元数据](assets/设计模式/solution-zh-16482864156665.png)

### 适用性

- 必须保存一个对象在某一时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。
- 如果一个接口让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

### 特点

- 保持封装边界。可避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息，把可能很复杂的 Originator 内部信息对其他对象屏蔽起来，从而保持了封装边界。
- 简化了原发器。
- 开销可能很大。如果原发器在生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。除非封装和恢复 Originator 状态的开销并不大，否则该模式可能并不适合。

### 参与者

- Memento（备忘录）
    - 备忘录存储原发器对象的内部状态。
    - 原发器根据需要决定备忘录存储原发器的哪些内部状态。
    - 防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者（Caretaker）只能看到备忘录的**窄接口**——它只能将备忘录传递给其他对象。相反，原发器能够看到一个**宽接口**，允许它访问返回到先前状态所需的所有数据。理想情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。
- Originator（原发器）
    - 原发器创建一个备忘录，用以记录当前时刻它的内部状态。
    - 使用备忘录恢复内部状态。
- Caretaker（管理者）
    - 负责保存好备忘录。
    - 不能对备忘录的内容进行操作或检查。

### 案例

- 各种含有历史记录、快照等概念的结构。
- 各类编辑器的**撤销**、**恢复**等功能。

### 对现有业务的思考

PHP语言里基本上可以使用**序列化**来生成对象的副本（以保存快照或状态），并且由于绝大部分 PHP 脚本是单线程运行，且会话时间非常有限， 通常会将对象的状态保存在比 RAM 更持久的存储设备中（例如关系型数据库、NoSQL等）。
